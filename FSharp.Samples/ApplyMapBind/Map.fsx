//An alternative interpretation of map is that it is a two parameter function that takes an
//elevated value ( E<a> ) and a normal function ( a->b ), and returns a new elevated value
//( E<b> ) generated by applying the function a->b to the internal elements of E<a>.

//map for Options
let applySimpleFnToOptionValue f opt =
    match opt with
    | None ->
        None
    | Some x ->
        Some (f x)

let rec applySimpleFnToListValues f list =
    match list with
    | [] ->
        []
    | head::tail ->
        (f head) :: (applySimpleFnToListValues f tail)

//Here are some examples of how map can be used in F#:

//Define a function in the normal world
let add1 x = x + 1

//A function lifted to the world of Options
let add1IfSomething = Option.map add1

//A function lifted to the world of Lists
let add1ToEachElement = List.map add1

